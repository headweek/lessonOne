//
//  main.swift
//  lesson One
//
//  Created by Salman Abdullayev on 20.09.23.
//

import Foundation

//1. Задание Необходимо разработать простое текстовое приложение для управления и отображения событий в календаре.
//
//Требования:
//
//Хранилище данных:
//
//Создайте словарь для хранения событий. Ключом в этом словаре должна быть строка, представляющая дату, а значением - массив строк, представляющий события этой даты.
var events: [String: [String]] = [:]
//Функциональность:
//
//a. Добавление события:
//
//Напишите функцию, которая принимает дату и событие в качестве параметров.
//Если для этой даты еще не существует списка событий, создайте его.
//Добавьте событие к указанной дате.
func addEvent(date: String, event: String) {
    if events[date] != nil {
        events[date]?.append(event)
    } else {
        events[date] = [event]
    }
}
//b. Отображение событий:
//
//Напишите функцию, которая принимает дату в качестве параметра.
//Функция должна выводить все события этой даты или сообщение о том, что событий на указанную дату нет.
func showEvents(forDate date: String) {
    if let eventsForDate = events[date] {
        print("События на \(date):")
        for event in eventsForDate {
            print("- \(event)")
        }
    } else {
        print("На \(date) нет запланированных событий.")
    }
}
//Интерфейс пользователя:
//
//Создайте функцию, которая предоставляет пользователю следующие опции:
//Добавить мероприятие
//Показать мероприятия на определенную дату
//Выйти из приложения
//В зависимости от выбора пользователя вызывайте соответствующие функции.
//Для получения ввода от пользователя используйте функцию readLine().
//Убедитесь, что приложение корректно обрабатывает неверный ввод пользователя.
//Запуск:
//
//После того как весь функционал будет реализован, инициируйте запуск приложения.
//Подсказки:
//
//Используйте условные операторы и циклы для реализации логики.
//Помните о безопасности работы с опциональными значениями в Swift.
//Ожидаемый результат: При запуске приложения пользователь должен видеть меню с опциями. После выбора опции он может добавить событие к определенной дате или просмотреть события на выбранную дату. Приложение должно корректно обрабатывать ввод и предоставлять информативные сообщения пользователю.
func mainMenu() {
    while true {
        print("Выберите опцию:")
        print("1. Добавить событие")
        print("2. Показать события на определенную дату")
        print("3. Выйти из приложения")
if let choice = readLine(), let option = Int(choice) {
switch option {
    case 1:
            print("Введите дату (в формате ДД.ММ.ГГГГ):")
    if let date = readLine() {
        print("Введите событие:")
        if let event = readLine() {
            addEvent(date: date, event: event)
            print("Событие добавлено!")
        }
    }
    case 2:
        print("Введите дату (в формате ДД.ММ.ГГГГ):")
        if let date = readLine() {
        showEvents(forDate: date)
        }
    case 3:
        print("До свидания!")
        return
    default:
        print("Неверный ввод. Пожалуйста, выберите правильную опцию.")
        }
        } else {
        print("Неверный ввод. Пожалуйста, выберите правильную опцию.")
    }
}
}
print("Добро пожаловать в приложение управления календарем!")
mainMenu()
//2 Задание: Хранилище настроек
//
//Описание: Разработайте текстовое приложение, которое позволяет пользователю устанавливать и извлекать значения настроек по ключам.
//
//Требования:
//
//Хранилище данных:
//
//Создайте приватный словарь для хранения настроек. Ключом в этом словаре должна быть строка, представляющая ключ настройки, а значением - строка, представляющая значение настройки.
var settings: [String: String] = [:]
//Функциональность:
//
//a. Установка настройки:
//
//Реализуйте метод, который принимает ключ и значение настройки в качестве параметров.
//Метод должен устанавливать или обновлять
func setSettings (key: String, value: String) {
settings[key] = value
print("Настройка '\(key)' установлена на значение '\(value)'.")
}
//3 Задание: Простой англо-русский переводчик
//
//Описание: Разработайте текстовое приложение, которое позволяет пользователю переводить слова с английского языка на русский, используя предопределенный словарь.
//
//Требования:
//
//Словарь перевода:
//
//Создайте словарь с парами "английское слово": "русское слово".
//Например: "hello" переводится как "привет", "world" как "мир" и так далее.
//Этот словарь будет служить вашей базой для перевода слов.
var slovarik: [String: String] = ["hello": "privet"]
//Функциональность:
//
//a. Перевод слова:
//
//Реализуйте функцию, которая принимает слово на английском языке в качестве параметра.
//Функция должна возвращать перевод этого слова с помощью словаря, если такой перевод существует. В противном случае, возвращайте nil.
func perevod (english: String) -> String? {
    return slovarik[english.lowercased()]
}

//b. Интерфейс пользователя:
//
//Создайте функцию, которая предоставляет пользователю две опции:
//Перевести слово.
//Выйти из приложения.

func mainMenu2 () {
    while true {
        print("viberi oviyu 1 ili 2")
        print("1. perevesti slovo")
        print("2.exit")
        if let choice = readLine(), let option = Int (choice){
            switch option {
            case 1:
                print("kakoye slovo nado perevesti.?")
                if let slovo = readLine(){
                    print(perevod(english: slovo) ?? print("nichevo ne naydeno"))
                }
            case 2:
                print("Poka")
                return
            default:
                print("Неверный ввод. Пожалуйста, выберите правильную опцию.")
                }
        } else {
            print("Неверный ввод. Пожалуйста, выберите правильную опцию.")
        }
        }
    }
print("perevodchik privet")
mainMenu2()

//Если пользователь выбирает опцию перевода слова, предложите ему ввести слово на английском.
//Используйте вашу функцию перевода, чтобы перевести введенное слово и выведите результат. Если слово не найдено в словаре, информируйте пользователя об этом.
//Запуск:
//
//После того как весь функционал будет реализован, инициируйте запуск приложения.
//Подсказки:
//
//Убедитесь, что вы обрабатываете различные варианты ввода пользователя, например, если пользователь вводит слово, которого нет в словаре.
//Используйте функцию readLine(), чтобы получить ввод от пользователя.
//Ожидаемый результат: При запуске приложения пользователь видит меню с опциями. После выбора опции "Перевести слово" ему предлагается ввести слово на английском. Приложение затем выдает русский перевод этого слова или сообщает пользователю, что перевод не найден.




//4. Задание: Справочник городов по странам
//
//Описание: Разработайте текстовое приложение для управления базой данных, содержащей страны и их города. Пользователь дprолжен иметь возможность добавлять и удалять города, а также просматривать список городов для определенной страны.
//
//Требования:
//
//База данных:

var straniMira: [String: Set<String>] = [:]

//
//Создайте словарь, где ключом является название страны, а значением - множество городов этой страны.
//Функциональность:
//
//a. Добавление города к стране:
//
//Реализуйте функцию, которая добавляет город к заданной стране.
//Если страна еще не существует в базе данных, создайте новую запись.
//Если страна уже есть в базе данных, просто добавьте город к множеству городов этой страны.

func dobavitStranu (strana: String, qorod: String) {
    if straniMira[strana] != nil{
        straniMira[strana]?.insert(qorod)
    }else{
        straniMira[strana] = [qorod]
    }
}

//b. Удаление города из страны:
//
//Реализуйте функцию, которая удаляет город из заданной страны.
//Если после удаления города у страны не осталось городов, удаляйте страну из базы данных.

func removeCity(from country: String, city: String) {
    if var cities = straniMira[country] {
        cities.remove(city)
        if cities.isEmpty {
            straniMira[country] = nil
            print("Город '\(city)' удален, и больше нет других городов в стране '\(country)'. Страна удалена из базы данных.")
        } else {
            straniMira[country] = cities
            print("Город '\(city)' удален из страны '\(country)'.")
        }
    } else {
        print("Город '\(city)' не найден в стране '\(country)'.")
    }
}
 
//c. Просмотр городов страны:
//
//Реализуйте функцию, которая отображает список городов для заданной страны.
//Если страны нет в базе данных или у нее нет городов, информируйте пользователя об этом.

func showCities (country: String) {
    if let cities = straniMira[country]{
        if cities.isEmpty{
            print("Pusto")
        }else{
            print("Города в стране '\(country)': \(cities.joined(separator: ", "))")
        }
    }else{
        print("Страна '\(country)' не найдена в базе данных.")
    }
}

//d. Интерфейс пользователя:
//
//Создайте функцию, предоставляющую пользователю меню с различными действиями.
//Предоставьте опции для добавления города, удаления города, просмотра городов страны и выхода из приложения.

func mainMenu3 () {
    while true {
        print("Privet viberi deystviye 1,2,3 ili 4")
        print("1. Dobavit qorod")
        print("2. Pokazat qoroda strani")
        print("3. Udalit qorod iz strani")
        print("4. Exit")
        if let option = readLine(), let choice = Int (option){
            switch choice {
            case 1:
                print("Vvedi Stranu?")
                if let strana = readLine(){
                    print("Kakoy qorod dobavit?")
                    if let qorod = readLine(){
                        dobavitStranu(strana: strana, qorod: qorod)
                    }
                }
                print("Sdelano !")
            case 2:
                print("Qoroda kakoy strani xochesh uvidet?")
                if let strana = readLine(){
                    showCities(country: strana)
                }
            case 3:
                print("Iz kakoy strani xochesh udalit qorod?")
                if let strana = readLine(){
                    print("Vvedit qorod kotoriy xochesh udalit:")
                    if let qorod = readLine(){
                        removeCity(from: strana, city: qorod)
                    }
                }
                print("Sdelano.)")
            case 4:
                print("Poka druq.)")
                return
            default:
                print("Ti shto to ne tak delayesh !!!")
            }
        } else {
            print("Oshibka vibora !!!")
        }
    }
}

print("Dobro pojalovar v Narniyu!")
mainMenu3()
//Запуск:
//
//После того как весь функционал будет реализован, инициируйте запуск приложения.
//Подсказки:
//
//Используйте Set<String> для хранения городов каждой страны, чтобы избежать дубликатов.
//Убедитесь, что вы обрабатываете все возможные случаи, например, добавление уже существующего города или удаление несуществующего города.
//Ожидаемый результат: При запуске приложения пользователь видит меню с различными опциями. Он может добавлять города, удалять их или просматривать список городов для определенной страны.


//5. Задание: Нахождение общих элементов двух массивов
//
//Описание: Разработайте функцию, которая определяет общие элементы между двумя массивами и возвращает их в виде нового массива.
//
//Требования:
//
//Функция commonElements:
//
//Входные параметры: два массива целых чисел - array1 и array2.

func commonElements (mass1: [Int], mass2: [Int]) -> Set<Int> {
    let array1 = Set(mass1)
    let array2 = Set(mass2)
    let commonArray = array1.intersection(array2)
    return commonArray
}
print(commonElements(mass1: [1,2,3,4,5,6], mass2: [1,2,7,8,9,0]))
//Возвращаемое значение: массив целых чисел.
//Логика функции:
//
//Преобразуйте каждый из входных массивов в множества (Set) для устранения возможных дубликатов и для использования встроенных операций множеств.
//Найдите пересечение двух множеств, что даст вам множество общих элементов.
//Преобразуйте результат обратно в массив и верните его.
//Пример использования:
//
//Создайте два тестовых массива: arrayA и arrayB.
//Вызовите функцию commonElements, передав эти массивы в качестве аргументов.
//Выведите на экран результат выполнения функции.
//Подсказки:
//
//Порядок элементов в результирующем массиве может зависеть от внутреннего устройства Set, поэтому не обязательно ожидать определенный порядок.


//6 Задание: Поиск общих друзей двух пользователей
//
//Описание: Разработайте систему для учета дружеских связей и функцию для определения общих друзей между двумя пользователями.
//
//Требования:
//
//Словарь friendsList:
//
//Ключи: строковые значения, представляющие имена пользователей.
//Значения: множества (Set), содержащие имена друзей соответствующего пользователя.
//Функция findCommonFriends:
//
//Входные параметры: две строки - user1 и user2, представляющие имена пользователей.
//Возвращаемое значение: множество строк (или nil в случае отсутствия какого-либо из пользователей в словаре).
//Логика функции:
//
//Проверьте, существуют ли оба пользователя в friendsList.
//Если один из пользователей или оба отсутствуют, верните nil.
//Если оба пользователя присутствуют, найдите и верните пересечение их множеств друзей.
//Пример использования:
//
//Вызовите функцию findCommonFriends, передав в неё имена двух пользователей.
//Определите и выведите результат. Если функция вернула nil, сообщите, что один из пользователей не найден в списке друзей.
//Подсказки:
//
//Ожидаемый результат:  После вызова функции и передачи в неё имен пользователей, вы должны увидеть их общих друзей. Например, для "Alice" и "Eve" результатом будет: "Общие друзья Alice и Eve: ["David", "Bob"]" (порядок может отличаться). Если один из пользователей отсутствует, вы увидите: "Один из пользователей не найден в списке друзей.".

func findCommonFriends (user1: [String], user2: [String]) -> Set<String>? {
    let friends1 = Set(user1)
    let friends2 = Set(user2)
    let commonFriends = friends1.intersection(friends2)
    
    return commonFriends
}
//7. Задание: Найти уникальные элементы в массиве
//
//Описание: Разработайте функцию, которая принимает массив целых чисел и возвращает новый массив, содержащий только уникальные значения из входного массива.
//
//Требования:
//
//Функция uniqueElements:
//Входной параметр: массив целых чисел - array.
//Возвращаемое значение: массив целых чисел.
//Логика функции:
//Преобразуйте входной массив в множество (Set). Это автоматически удалит все дубликаты из массива, так как множества содержат только уникальные элементы.
//Преобразуйте полученное множество обратно в массив и верните его.
//Пример использования:
//Вызовите функцию uniqueElements, передав в неё массив чисел.
//Отобразите результат. В результате выполнения функции, все дублирующиеся числа из входного массива должны быть удалены. Например, из массива [1, 2, 3, 1, 2, 4, 5] функция вернет массив [1, 2, 3, 4, 5] (порядок чисел может отличаться).
//Подсказки:
//
//Ожидаемый результат: После вызова функции и передачи в неё массива, вы должны увидеть массив без дубликатов. Например, для массива [1, 2, 3, 1, 2, 4, 5] результатом может быть: [2, 3, 1, 5, 4] (учтите, что порядок элементов может отличаться).

func uniqueElements (array: [Int]) -> Set<Int> {
    return Set(array)
}
print(uniqueElements(array: [1,2,2,3,3,4,4,5,5]))

//8 Задание:  Реализация простого телефонного справочника
//
//Описание: Создайте базовую систему управления телефонным справочником, позволяющую добавлять, удалять и искать номера телефонов по именам.
//
//Требования:
//
//Справочник:
//
//Используйте словарь (Dictionary) для хранения пар "имя-номер телефона".
//Функции:
//
//addNumber:
//Входные параметры: имя (name) и номер телефона (number).
//Добавляет указанный номер телефона для данного имени в справочник.
//removeNumber:
//Входной параметр: имя (name).
//Удаляет номер телефона, связанный с данным именем из справочника.
//findNumber:
//Входной параметр: имя (name).
//Возвращает номер телефона для данного имени (если он есть в справочнике) или nil, если такого имени нет.
//Пример использования:
//
//Добавьте несколько номеров телефонов в справочник.
//Выполните поиск по имени. Проверьте и отобразите результаты.
//Удалите номер телефона из справочника.
//Попробуйте найти этот номер снова, чтобы удостовериться, что он был удален.
//Ожидаемый результат:
//При добавлении и поиске номеров вы должны получить ожидаемые результаты на основе текущего содержимого справочника. Если имя не найдено в справочнике, функция поиска вернет nil, и вы должны уведомить пользователя об этом.
//
//Подсказки:
//
//При работе со словарями в Swift использование метода removeValue(forKey:) удаляет значение для заданного ключа (если оно существует). Если ключа нет, метод не делает ничего.
//Чтобы проверить, существует ли значение для определенного ключа в словаре, вы можете просто использовать индексацию словаря: dictionary[key]. Если ключ отсутствует, вам вернется nil.

var spravochnik: [String: String] = [:]

func addNumber (name: String, number: String) {
    spravochnik[name] = number
    print("Dobavleno \(name) i nomer \(number)")
}

func removeNumber (name: String) {
    spravochnik[name] = nil
    print("Udalen kontakt \(name)")
    
}

func findNumber (name: String) -> String? {
    print("Vot tebe nomer kontakta \(name)")
    return spravochnik[name]
}

func mainMenu4 () {
    while true {
        print("Spravochnik privetstvuyet tebya!")
        if let choice = readLine(), let option = Int (choice) {
            switch option {
            case 1:
                if let name = readLine(){
                    if let number = readLine(){
                        addNumber(name: name, number: number)
                    }
                }
            case 2:
                if let name = readLine(){
                    removeNumber(name: name)
                }
            case 3:
                if let name = readLine(){
                    findNumber(name: name)
                }
            case 4:
                return
            default:
                print("ERROR")
            }
        }
    }
}

mainMenu4()

//9 Задание: Реализация теста по умножению
//
//Описание:
//Создайте систему для генерации и проведения теста из пяти уникальных вопросов по умножению для чисел от 1 до 10. После завершения теста программа должна выводить оценку на основе количества правильных ответов.
//
//Требования:
//
//Структуры данных:
//
//questionsAsked: Множество (Set), которое используется для отслеживания заданных вопросов, чтобы гарантировать уникальность каждого вопроса.
//questionsAndAnswers: Словарь (Dictionary), где ключ - это вопрос, а значение - это правильный ответ на этот вопрос.
//correctAnswers: Счетчик правильных ответов пользователя.
//Функции:
//
//generateUniqueMultiplicationQuestion:
//Генерирует уникальный вопрос по умножению.
//Возвращает кортеж из строки вопроса и правильного ответа.
//determineGrade:
//Определяет оценку на основе количества правильных ответов.
//Возвращает символьную оценку.
//*Тест:*
//
//Пройдитесь через цикл 10 раз (10 вопросов).
//Задайте пользователю вопрос и ожидайте ответ.
//Проверьте ответ пользователя на правильность.
//После завершения теста, определите и выведите оценку.
//Подсказки:
//
//Используйте множества для гарантирования уникальности вопросов.
//Словарь позволяет быстро связать вопрос с его ответом.
//Используйте switch в функции determineGrade для определения оценки на основе количества правильных ответов.
//Ожидаемый результат:
//После запуска кода пользователь ответит на 10 уникальных вопросов по умножению. После завершения теста будет выведена его оценка.
